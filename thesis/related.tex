本研究では，末永らが提案したメモリリークを静的に検出する型システム
\cite{DBLP:conf/aplas/SuenagaK09}を制御文で拡張しした．また，その拡張した
型システムに基いて検証器を実装した．検証器の実装においては，Leoryらによっ
て実装されたC言語のコンパイラCompCert
\cite{DBLP:journals/cacm/Leroy09,DBLP:conf/itp/KrebbersLW14 }を拡張する形
で実装した．また型システムの拡張も，CompCertで使われている中間言語
Clight \cite{DBLP:journals/jar/BlazyL09} を元にしている．

CompCertを使用した他の研究としては\cite{DBLP:conf/popl/StewartBCA15}など
がある．従来のCompCertは他のモジュール内の関数の呼び出しの正しさはは保証
しない．そこで，この研究は他のモジュール内の関数の呼び出しなどの正しさも
保証するComposite CompCertを提案している．

本研究で，SMTソルバとして使用した Z3 を利用した研究として
\cite{DBLP:conf/fmcad/McMillan11}などがある．これは，Z3を利用して，モデル
検査の分野で使用される補間を求める手法を提案している．

型エラースライサーは，静的型付けの行われている関数型言語に対して，型エラー
が発生した際に，型エラーに関係しているプログラム地点をスライスとして出力
するツールである\cite{DBLP:conf/esop/HaackW03,DBLP:conf/dsl/DineshT97}．
更に，型エラースライサーは本来，関数型言語を対象としていたが，近年Javaな
どの言語に対しても研究が行われている\cite{DBLP:conf/pepm/BoustaniH09}．一
般の静的型付け言語において，型推論はプログラムを抽象構文木に変換した後，
各ノードに対して型付け規則に基いて型がつくかどうか確認していき，失敗した
場合，失敗したノードを1つだけ型エラーの原因として出力する．しかし，型エラー
の原因が1つしか挙げられないため，プログラマは型エラーの原因を正確に特定す
ることができない．そこで型エラースライサーは，各ノードから生成された制約
式にラベルをつけ，制約式全体が充足不能とわかった場合，充足不能となってい
る最小の制約式の集合を抽出し，その集合に含まれている制約式のラベルからプ
ログラム地点を特定し，スライスとして出力するということをしている．本研究
の型エラースライサーもこの考えに基づいて実装をしている．\ref{section4}で
述べたように，制約式の充足不能の原因を抽出する際に，SMTソルバが返す
unsat core を用いている．また，これまでの型エラースライサーは単純型を対象
としていたが，本研究では，所有権型を対象としている．\cite{飯村枝里2007,
飯村枝里2008}では，並行プログラミングにおけるレースの原因やデッドロックの
原因を型エラースライサーを用いて特定しているが，制約式の充足不能の原因特
定に unsat core は用いられていない．

他のメモリリークの検証器は，XieらによるSATソルバを用いた
\cite{DBLP:conf/sigsoft/XieA05}や，Cheremらによるグラフを用いた
\cite{DBLP:conf/pldi/CheremPR07}などがある．しかし，両方ともループを健全
な形で扱うことができない．

Hoare 論理を拡張して，領域の確保や解放，領域へのアクセスなどメモリに関す
る操作をを扱えるようにした体系としてSeparation Logic
\cite{DBLP:conf/lics/Reynolds02}が提案されている．この Separation Logic
に基いて，メモリリークの検出やエイリアス解析などを行う手法として Shape
analysis
\cite{DBLP:conf/cav/BerdineCCDOWY07,DBLP:conf/tacas/DistefanoOY06,
DBLP:conf/pldi/GuoVA07} という手法がある．しかし，これらの手法は検出に非
常に時間がかってしまう．