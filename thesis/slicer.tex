\subsection{制約解消}
制約式変換を終えた制約式は，SMTソルバで解ける形になっている．その制約式を
SMTソルバで解くことで，制約式が充足可能かどうか判定することができる．今回
の実装ではSMTソルバには，Z3 \cite{DBLP:conf/tacas/MouraB08}を使用した．ソ
ルバが制約を充足可能と判定した場合は，プログラムに型がつき，メモリ操作に
関する誤りが発生していないことがわかる．ソルバが充足不能と判定した場合は，
同時にunsat coreを返す．unsat coreとは，制約式の充足不能性の原因となって
いる制約式の部分集合である．unsatの場合は，プログラム中のどこかでメモリ操
作に関する誤りがあり，その箇所が型エラーの原因となっている．その箇所を特
定するのは，小さなプログラムでは容易だが，大きなプログラムだと困難である．
そこで，unsat coreを用いて型エラーの原因となっている命令の集合をプログラ
ム中から切り出して，表示する．この情報は，プログラマが型エラーの原因を特
定するのに役立つと考えられる．

\subsection{型エラースライサー}
型エラースライサーは，制約式の集合とunsat coreを入力として，型エラーの原
因に関係している命令の行番号をスライスとして出力する．unsat coreには制約
式の充足不能性の原因，つまり型エラーの原因となっている制約式が含まれてい
る．そこで，unsat coreに含まれている各制約式がそれぞれどの命令から生成さ
れたものなのかを調べる．制約式には，その制約式を生成した命令の行番号
$loc$が含まれているので，unsat coreに含まれている各制約式の$loc$をまとめ
たものをスライスとすればよい．

今回ソルバとして使用したZ3は，unsat coreを制約式の名前で返す．そのため，
Z3に制約式を渡す際に，各制約式に名前をつけ，どの制約式にどういう名前をつ
けたのかを記録しておくことで，Z3がunsat coreとして返してきた制約式の名前
から制約式を特定し，$loc$を調べることができる．

\begin{example}[型エラースライサー]
  プログラム \ref{rec_struct_unsat}\ (付録参照)\ を例に挙げる．このプログラム
  は，再帰を含む構造体\texttt{list}を使って単方向リストの操作を行っている
  プログラムである．\texttt{make\_list}で単方向リストの各要素に新しいメモ
  リ領域を割り当て，\texttt{free\_all\_list}でそれら全てを解放する．しか
  し，\texttt{free\_all\_list}内で，\texttt{free}を実行し忘れているため，
  メモリリークが発生している．

  このプログラムから制約式を生成し，Z3で解くと
\begin{verbatim}
    unsat
    (c_70 c_67 c_66 c_64 c_54 c_52
     c_49 c_48 c_32 c_31 c_8 c_3 c_7)
\end{verbatim}
  を返す．メモリリークが発生しているため制約式は充足不能である．
  また充足不能のため，unsat coreを一緒に返している．
  unsat coreの各要素は，制約式の名前である．
  型エラースライサーは，これらの名前がついた制約式を生成した命令を探し
  それの行番号をスライスとして出力する．
\begin{verbatim}
    [11; 18; 30; 32; 39; 40; 43]
\end{verbatim}

  $30$行目の\texttt{malloc}で新しいメモリ領域を
  割当て，$32$行目の\texttt{return}でその変数を返り値としているため，$39$行
  目で\texttt{make\_list}を呼び出しその返り値を代入している変数\texttt{l}に
  は，所有権が与えられているはずである．しかし，$40$行目で
  \texttt{free\_all\_list}を呼び出しているにもかかわらず，$43$行目で，関数
  の終了時には関数の局所変数の所有権，つまり\texttt{l}内の所有権は全て$0$に
  なっていないといけないという条件をみたすことができていない．更に$18$行目
  の\texttt{free\_all\_list}もスライスに含まれていることから，
  \texttt{free\_all\_list}の実装が間違っているのではないかと，プログラマは
  推測することができる．
\end{example}