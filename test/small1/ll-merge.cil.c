/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

//#line  14 "test/small1/freesafety_test.h"
struct ll_node {
   struct ll_node *next ;
};
//#line  18
extern void malloc(void **__fst_ret , unsigned int size ) ;
//#line  19
extern void free(void *p ) ;
//#line  20
extern void _fst_assume_null(void *p ) ;
//#line  23
extern void random(int *__fst_ret ) ;
//#line  4 "test/small1/ll-merge.c"
void merge(struct ll_node **__fst_ret , struct ll_node *l1 , struct ll_node *l2 ) 
{ int tmp ;
  int *__vericon_ptr_tmp ;

  {
//#line  4
  __vericon_ptr_tmp = & tmp;
//#line  5
  if ((unsigned int )l1 == (unsigned int )((struct ll_node *)0)) {
//#line  6
    _fst_assume_null((void *)l1);
    {
//#line  7
    *__fst_ret = l2;
//#line  7
    return;
    }
  } else {
//#line  8
    if ((unsigned int )l2 == (unsigned int )((struct ll_node *)0)) {
//#line  9
      _fst_assume_null((void *)l2);
      {
//#line  10
      *__fst_ret = l1;
//#line  10
      return;
      }
    } else {
//#line  11
      random(__vericon_ptr_tmp);
//#line  11
      if (*__vericon_ptr_tmp) {
//#line  12
        merge(& l1->next, l1->next, l2);
        {
//#line  13
        *__fst_ret = l1;
//#line  13
        return;
        }
      } else {
//#line  15
        merge(& l2->next, l1, l2->next);
        {
//#line  16
        *__fst_ret = l2;
//#line  16
        return;
        }
      }
    }
  }
}
}
//#line  20 "test/small1/ll-merge.c"
void make_list(struct ll_node **__fst_ret , unsigned int n ) 
{ unsigned int i ;
  struct ll_node *ret ;
  struct ll_node *tmp ;
  void *tmp___0 ;
  void **__vericon_ptr_tmp___0 ;

  {
//#line  20
  __vericon_ptr_tmp___0 = & tmp___0;
//#line  22
  i = 0U;
//#line  23
  ret = (struct ll_node *)'\000';
//#line  24
  tmp = (struct ll_node *)'\000';
//#line  25
  i = 0U;
//#line  25
  while (i < n) {
//#line  26
    malloc(__vericon_ptr_tmp___0, sizeof(struct ll_node ));
//#line  26
    tmp = (struct ll_node *)*__vericon_ptr_tmp___0;
//#line  27
    tmp->next = ret;
//#line  28
    ret = tmp;
//#line  25
    i ++;
  }
  {
//#line  30
  *__fst_ret = ret;
//#line  30
  return;
  }
}
}
//#line  33 "test/small1/ll-merge.c"
void free_list(struct ll_node *l ) 
{ struct ll_node *p ;
  struct ll_node *tmp ;

  {
//#line  35
  p = l;
//#line  36
  while ((unsigned int )p != (unsigned int )((struct ll_node *)0)) {
//#line  37
    tmp = p->next;
//#line  38
    free((void *)p);
//#line  39
    p = tmp;
  }
//#line  41
  _fst_assume_null((void *)p);
//#line  42
  return;
}
}
//#line  44 "test/small1/ll-merge.c"
void main(int *__fst_ret , int argc , char **argv ) 
{ struct ll_node *tmp ;
  struct ll_node *tmp___0 ;
  struct ll_node *tmp___1 ;
  struct ll_node **__vericon_ptr_tmp ;
  struct ll_node **__vericon_ptr_tmp___0 ;
  struct ll_node **__vericon_ptr_tmp___1 ;

  {
//#line  44
  __vericon_ptr_tmp = & tmp;
//#line  44
  __vericon_ptr_tmp___0 = & tmp___0;
//#line  44
  __vericon_ptr_tmp___1 = & tmp___1;
//#line  46
  make_list(__vericon_ptr_tmp, 5U);
//#line  46
  make_list(__vericon_ptr_tmp___0, 5U);
//#line  46
  merge(__vericon_ptr_tmp___1, *__vericon_ptr_tmp___0, *__vericon_ptr_tmp);
//#line  46
  free_list(*__vericon_ptr_tmp___1);
  {
//#line  47
  *__fst_ret = 0;
//#line  47
  return;
  }
}
}
